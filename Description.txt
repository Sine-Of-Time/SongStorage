The following will be a write-up of the code for my personal use, I will document the parts of the code I find most important to review before interviews etc
To start off with, the code follows the structure of using an BST_Song binary search tree, BST_SongTile, and Heap to allow for operations to be preformed by title,ID, or duration and improving performance to O(log(n)) for Both BST object insertion, search and removal. Along with push, pop, and remove for the heap being O(log(n))  as required by our professor  
It can be noted, we also do not remove songs, rather just marked them as removed as the same song is often referenced in multiple trees and if we just deleted it we would end up with multiple null pointers 

1.Song Class
The main idea of this class was to encapsulate all of the data and behavior for a single song with variables such as songID(int), songTitle(Str), songDuration(int), and removed(bool), where removed denotes that an song has been removed in BST_song.
The most important operator is << which is overloaded to print song info

2.BST_Song(Binary Search Tree for Song ID),
One of two binary trees for dealing with Song objects, this specifically deals with songID, using it for all operations, and as stated has O(log(n)) for most operation runtimes. It has an Song data ptr, root ptr and NodeBST ptr for the right and left node. 
insert(Song &value) creates a new node song based on the parameter and the places it into the BST. It finds the desired location by comparing the new value to root and going to the left using left ptr if the new ID is smaller and going right if the new ID is larger 

remove(song &value) searches for the node whose songID matches the value.getSongID(), does this removal with standard BST logic, in that if removing leaf node, remove directly, if removing node with one child, replace the node with its non-null child. If the removing node has two children, find the smallest node in the right subtree and replace it wit the current node 

search(song &value) transverse the tree by comparing the SongID, if smaller go left, if larger go right, if it finds the node, return true

printInOrder(NodeBST *node) recursively prints the tree from left subtree -> node -> right subtree, will skip songs marked as removed

...

3.BST_songTitle is an BST specialized for storing and managing multiple songs by their title and uses the song title for all operations, the insert,remove,search and printInOrder methods are all the same as BST_Song when accounting for this. There are some helper method from Jackson, denoted Jackson helper mess, which I have no idea what they do lol

4.Heap(Max-Heap by Song Duration) which uses an vector-based max heap to store pointers to Songs. The song with the largest duration is at the top of the heap and duration is the song used to organize the heap. Making the key the song duration. 

Push(Song *value) appends the new song pointer to the end of the heap and then used PercolateUp function to bubble up the new song ptr to its correct location

Pop() removes and returns the root then replaces the root with the last element in the heap and calls PercolateDown to push down this new root so the largest element is the root

Remove(int index) is used to remove the song at the index in the vector, this is done by swapping the target element with the last and then popping it back. Then using PercolateDowm/PercolateUp depending on if the swapped value is larger or smaller

Peek() returns but does not remove the top element 

PercolateUp(int index) repeatedly compares the item at index with its parent until either the child duration is greater then parent and they swap or no child is larger or we reach the bottom 

PercolateDown(int index) Compares the node at index with its children. Swaps it with the larger child if the child is bigger (max-heap property). Repeats until no child is larger or we reach the bottom.

Interaction with Song Class:
  
